"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpile = exports.supports = exports.loaders = void 0;
var tslib_1 = require("tslib");
var esbuild_1 = require("esbuild");
var fs_1 = tslib_1.__importDefault(require("fs"));
var path_1 = tslib_1.__importDefault(require("path"));
var cache_1 = tslib_1.__importDefault(require("./cache"));
var defaultOptions = { type: "bundle", debug: false };
var commonOptions = {
    format: "cjs",
    logLevel: "error",
    target: ["node" + process.version.slice(1)],
    minify: false,
    sourcemap: "inline",
};
var pkgPath = path_1.default.resolve(".", "package.json");
var externals = [];
if (fs_1.default.existsSync(pkgPath)) {
    var pkg = JSON.parse(fs_1.default.readFileSync(pkgPath, { encoding: "utf-8" }));
    externals = tslib_1.__spreadArrays(Object.keys((_a = pkg.dependencies) !== null && _a !== void 0 ? _a : {}), Object.keys((_b = pkg.devDependencies) !== null && _b !== void 0 ? _b : {}));
}
exports.loaders = {
    ".js": "js",
    ".mjs": "js",
    ".cjs": "js",
    ".jsx": "jsx",
    ".ts": "ts",
    ".tsx": "tsx",
    // ".css": "css",
    ".json": "json",
};
function supports(filename) {
    if (filename.includes("node_modules"))
        return false;
    return path_1.default.extname(filename) in exports.loaders;
}
exports.supports = supports;
function _transform(code, filename) {
    var ret = esbuild_1.transformSync(code, tslib_1.__assign(tslib_1.__assign({}, commonOptions), {
        loader: exports.loaders[path_1.default.extname(filename)],
        sourcefile: filename,
    }));
    return ret.code;
}
function _bundle(code, filename) {
    var ext = path_1.default.extname(filename);
    return esbuild_1.buildSync(tslib_1.__assign(tslib_1.__assign({}, commonOptions), {
        loader: exports.loaders,
        bundle: true,
        platform: "node",
        stdin: {
            sourcefile: filename,
            contents: code,
            resolveDir: path_1.default.dirname(filename),
            loader: exports.loaders[ext],
        },
        external: externals,
        write: false,
    }))
        .outputFiles.map(function (f) { return f.text; })
        .join("\n");
}
function transpile(code, filename, _options) {
    var options = tslib_1.__assign(tslib_1.__assign({}, defaultOptions), _options);
    if (options.type == "bundle") {
        if (options.debug)
            console.log("\uD83D\uDCE6 " + filename);
        return _bundle(code, filename);
    }
    else if (options.type == "transform") {
        return cache_1.default.get(filename, function () {
            if (options.debug)
                console.log("\uD83D\uDCE6 " + filename);
            return _transform(code, filename);
        });
    }
    throw new Error("Invalid transpilation option " + options.type);
}
exports.transpile = transpile;
//# sourceMappingURL=esbuild.js.map